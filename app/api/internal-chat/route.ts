import { NextResponse } from "next/server";
import { prisma } from "../../lib/prisma";
import { getDefaultWorkspaceId } from "../../lib/config";
import { runInternalOrchestrator } from "../../lib/orchestrator";
import { generateDefaultSlots, formatSlotsText } from "../../lib/scheduling";

// Internal chat = one test conversation per workspace with channel "INTERNAL"

// GET /api/internal-chat
// → returns the internal conversation + all messages (oldest → newest)
export async function GET() {
  try {
    const workspaceId = getDefaultWorkspaceId();

    const conversation = await prisma.conversation.findFirst({
      where: {
        workspaceId,
        channel: "INTERNAL",
      },
      orderBy: { createdAt: "asc" },
      include: {
        messages: {
          orderBy: { createdAt: "asc" },
        },
        lead: true,
      },
    });

    if (!conversation) {
      return NextResponse.json(
        {
          conversation: null,
          messages: [],
        },
        { status: 200 },
      );
    }

    return NextResponse.json(
      {
        conversation: {
          id: conversation.id,
          leadId: conversation.leadId,
          language: conversation.language,
        },
        messages: conversation.messages,
      },
      { status: 200 },
    );
  } catch (error) {
    console.error("INTERNAL_CHAT_GET_ERROR", error);
    return NextResponse.json(
      { error: "Server error while fetching internal chat." },
      { status: 500 },
    );
  }
}

// POST /api/internal-chat
// Body: { message: string }
// → creates INBOUND + OUTBOUND messages in the INTERNAL conversation
//   OUTBOUND text is generated by the orchestrator (flows + upsell + slots)
export async function POST(req: Request) {
  try {
    const workspaceId = getDefaultWorkspaceId();
    const body = await req.json();
    const { message } = body ?? {};

    if (!message || typeof message !== "string") {
      return NextResponse.json(
        { error: "Field 'message' is required." },
        { status: 400 },
      );
    }

    // Find or create the internal conversation
    let conversation = await prisma.conversation.findFirst({
      where: {
        workspaceId,
        channel: "INTERNAL",
      },
      orderBy: { createdAt: "asc" },
    });

    if (!conversation) {
      conversation = await prisma.conversation.create({
        data: {
          workspaceId,
          channel: "INTERNAL",
          externalId: "internal-test",
          language: "en",
        },
      });
    }

    // Load workspace to get timezone
    const workspace = await prisma.workspace.findUnique({
      where: { id: workspaceId },
    });

    const timezone = workspace?.timezone || "Asia/Dubai";

    // Run orchestrator (language + flow + base reply with upsell)
    const orchestration = await runInternalOrchestrator(message);

    // Generate default slots for this workspace
    const slots = generateDefaultSlots(timezone);
    const slotsText = formatSlotsText(
      orchestration.language,
      slots,
      timezone,
    );


    const fullReply = [orchestration.reply, "", slotsText]
      .filter(Boolean)
      .join("\n");

    // Update conversation language + last inbound timestamp
    await prisma.conversation.update({
      where: { id: conversation.id },
      data: {
        language: orchestration.language,
        lastInboundAt: new Date(),
      },
    });

    // Create inbound message (from "client" → garage)
    const inbound = await prisma.message.create({
      data: {
        conversationId: conversation.id,
        direction: "INBOUND",
        text: message,
      },
    });

    // Create outbound message (Rivo reply with slots)
    const outbound = await prisma.message.create({
      data: {
        conversationId: conversation.id,
        direction: "OUTBOUND",
        text: fullReply,
        rawPayload: {
          language: orchestration.language,
          flow: orchestration.flow,
          slots,
        } as any,
      },
    });

    // Return latest state
    return NextResponse.json(
      {
        conversationId: conversation.id,
        inbound,
        outbound,
        meta: {
          language: orchestration.language,
          flow: orchestration.flow,
        },
      },
      { status: 201 },
    );
  } catch (error) {
    console.error("INTERNAL_CHAT_POST_ERROR", error);
    return NextResponse.json(
      { error: "Server error while sending internal chat message." },
      { status: 500 },
    );
  }
}
